(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{450:function(t,a,s){"use strict";s.r(a);var e=s(19),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"示例-alluxio分层存储配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#示例-alluxio分层存储配置"}},[t._v("#")]),t._v(" 示例 - Alluxio分层存储配置")]),t._v(" "),a("p",[t._v("Fluid所使用的底层存储引擎"),a("a",{attrs:{href:"https://github.com/Alluxio/alluxio",target:"_blank",rel:"noopener noreferrer"}},[t._v("Alluxio"),a("OutboundLink")],1),t._v("支持分层的多目录存储. 通过合理的分层存储配置, 能够为用户提升总体I/O吞吐量, 减小数据密集型引用出现数据访问瓶颈的可能性.")]),t._v(" "),a("p",[t._v("本文档将介绍在Fluid中如何对AlluxioRuntime进行声明式的配置,以开启Alluxio分层存储的相关支持.")]),t._v(" "),a("p",[t._v("更多与Alluxio分层存储的配置与技术细节,请参考"),a("a",{attrs:{href:"https://docs.alluxio.io/os/user/stable/cn/core-services/Caching.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Alluxio存储官方文档"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"前提条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前提条件"}},[t._v("#")]),t._v(" 前提条件")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/fluid-cloudnative/fluid",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fluid"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("请参考"),a("a",{attrs:{href:"https://github.com/fluid-cloudnative/fluid/blob/master/docs/zh/userguide/install.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fluid安装文档"),a("OutboundLink")],1),t._v("完成安装")]),t._v(" "),a("h2",{attrs:{id:"单层存储配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单层存储配置"}},[t._v("#")]),t._v(" 单层存储配置")]),t._v(" "),a("p",[t._v("以下是一个典型的AlluxioRuntime资源对象配置:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" data.fluid.io/v1alpha1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AlluxioRuntime\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" dataset\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("tieredstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("levels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /dev/shm\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mediumtype")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" MEM\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("quota")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2Gi\n")])])]),a("p",[t._v("在上述示例中,"),a("code",[t._v("spec.tieredstore.levels")]),t._v("目录下仅包含一层存储配置,这意味着Alluxio将以单层存储的配置方式运行.")]),t._v(" "),a("p",[t._v("分层配置中各项属性解释如下:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("path")]),t._v(": 数据缓存在Alluxio Worker所在结点的实际存储位置")]),t._v(" "),a("li",[a("code",[t._v("mediumtype")]),t._v(': 取值只能为"MEM","SSD","HDD"三者之一,用于指明'),a("code",[t._v("path")]),t._v("目录所使用的存储设备类型.")]),t._v(" "),a("li",[a("code",[t._v("quota")]),t._v(": 该层存储所允许的最大缓存容量(Cache Capacity)")])]),t._v(" "),a("h2",{attrs:{id:"单层多目录存储配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单层多目录存储配置"}},[t._v("#")]),t._v(" 单层多目录存储配置")]),t._v(" "),a("p",[t._v("介绍单层多目录存储配置的最好方式是以一个例子进行说明:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" data.fluid.io/v1alpha1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AlluxioRuntime\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" dataset\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("tieredstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("levels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /mnt/ssd0/cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("/mnt/ssd1/cache\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mediumtype")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" SSD\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("quota")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 4Gi\n")])])]),a("p",[t._v("为了启用Alluxio的单层多目录存储配置,唯一要做的修改是在"),a("code",[t._v("path")]),t._v("属性中增加若干新的目录,这些目录之间需以逗号分隔.以上述AlluxioRuntime资源对象的yaml配置为例,"),a("code",[t._v("path")]),t._v('属性中包含了"/mnt/ssd0/cache"和"mnt/ssd1/cache",这意味着Alluxio将同时使用这两个目录作为数据缓存的实际存储位置.')]),t._v(" "),a("p",[t._v("上述yaml配置同样说明了单层多目录存储配置的一个实用场景: 当应用的数据访问瓶颈来自于存储设备本身时(例如:磁盘带宽上限),上述配置使得Alluxio可以将数据缓存放置在同层的多个不同的目录中,这些目录分别位于不同存储设备的挂载点下(例如上例中的"),a("code",[t._v("/mnt/ssd0")]),t._v("和"),a("code",[t._v("/mnt/ssd1")]),t._v("),于是大量数据访问请求带来的压力也将被均摊到多个存储设备之上,减轻数据访问造成的瓶颈.")]),t._v(" "),a("blockquote",[a("p",[t._v("注意: 目前Fluid仅支持同构存储设备类型的同层多目录配置.换言之,目前您将无法不同类型的存储介质混合使用")])]),t._v(" "),a("p",[t._v("另外,值得注意的是, 如果在同层使用多目录配置,那么"),a("code",[t._v("quota")]),t._v("所指明的最大缓存容量上限同样会被多个目录均摊.以上述yaml配置为例进行说明:"),a("code",[t._v("quota")]),t._v('被设置为了"4Gi",那么'),a("code",[t._v("path")]),t._v('中设置的两个目录均会获得最大"2Gi"(4Gi / 2)的缓存容量.')]),t._v(" "),a("p",[t._v('如果上述"缓存容量均摊"的配置策略无法满足需求, Fluid同样提供了更加细粒度的缓存容量配置方式:')]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" data.fluid.io/v1alpha1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AlluxioRuntime\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" dataset\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("properties")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# [default property in fluid]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# alluxio.worker.allocator.class: alluxio.worker.block.allocator.MaxFreeAllocator")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("tieredstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("levels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /mnt/ssd0/cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("/mnt/ssd1/cache\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mediumtype")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" SSD\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#quota: 4Gi")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("quotaList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 3Gi"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("2Gi\n")])])]),a("p",[t._v("通过设置"),a("code",[t._v("quotaList")]),t._v("属性可以实现多目录缓存容量的细粒度配置."),a("code",[t._v("quotaList")]),t._v("必须与"),a("code",[t._v("path")]),t._v("中的目录数量一致, "),a("code",[t._v("quotaList")]),t._v('中的各个缓存容量上限以逗号(",")进行分隔,各缓存容量上限按先后顺序分配到对应的目录下.\n例如,上述yaml配置意味着"/mnt/ssd0/cache"目录的最大缓存容量为"3Gi",而"/mnt/ssd1/cache"目录的最大缓存容量为"2Gi".')]),t._v(" "),a("p",[t._v("另一个与多目录存储配置相关的配置是缓存目录的使用策略.该策略由"),a("code",[t._v("alluxio.worker.allocator.class")]),t._v("这一Alluxio Property进行配置. Fluid默认使用"),a("code",[t._v("alluxio.worker.block.allocator.MaxFreeAllocator")]),t._v("作为数据缓存的放置策略.")]),t._v(" "),a("p",[t._v("Alluxio支持三种数据缓存的放置策略, 用户可通过设置Alluxio Property("),a("code",[t._v("alluxio.worker.allocator.class")]),t._v(")修改该策略:")]),t._v(" "),a("ul",[a("li",[t._v('"MaxFreeAllocator": 总是选择当前最大空余容量的缓存目录')]),t._v(" "),a("li",[t._v('"RoundRobinAllocator": 以RoundRobin方式选择缓存目录')]),t._v(" "),a("li",[t._v('"GreedyAllocator": 总是选择第一个可用的缓存目录')])]),t._v(" "),a("h2",{attrs:{id:"多层存储配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多层存储配置"}},[t._v("#")]),t._v(" 多层存储配置")]),t._v(" "),a("p",[t._v("以下为多层存储配置的一个示例:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" data.fluid.io/v1alpha1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AlluxioRuntime\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" dataset\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("tieredstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("levels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /dev/shm\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mediumtype")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" MEM\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("quota")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2Gi\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("path")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" /mnt/ssd0/cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("/mnt/ssd1/cache\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mediumtype")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" SSD\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("quotaList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 3Gi"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("2Gi\n")])])]),a("p",[t._v("多层存储配置可以对每层进行各自的单目录或多目录配置.例如,在上述示例中,我们定义了两层数据缓存:其中第一层使用内存进行高速的数据访问,而第二层则使用SSD作为容量更大但访问速度稍慢的次级数据缓存.在第二层中,我们配置了多个目录(多块SSD磁盘)以均摊大量数据访问请求带来的压力.")]),t._v(" "),a("p",[a("code",[t._v("spec.tieredstore.levels")]),t._v("中定义的层级顺序不会影响Alluxio集群分层存储的层级顺序.在Alluxio集群启动前,Fluid会按照"),a("code",[t._v("mediumtype")]),t._v('对多个层级进行重排序,以保证数据访问速度快的存储介质("MEM" < "SSD" < "HDD")会被优先使用.')]),t._v(" "),a("blockquote",[a("p",[t._v("注意: 多层存储配置的Alluxio使用不同的方式计算存储使用量. 在目前的Fluid版本下,这会使得Alluxio已缓存比例("),a("code",[t._v("Dataset.Cached")]),t._v("以及"),a("code",[t._v("Dataset.CachedPercentage")]),t._v("属性)受到一定的精确度影响.")])])])}),[],!1,null,null,null);a.default=n.exports}}]);